diff a/server/src/main/java/io/tilt/minka/core/leader/distributor/ReplicationDispatcher.java b/server/src/main/java/io/tilt/minka/core/leader/distributor/ReplicationDispatcher.java	(rejected hunks)
@@ -41,59 +41,41 @@ class ReplicationDispatcher {
 		
 		final Shard leader = scheme.getCommitedState().findShard(leaderId.getId());
 		// those of current plan
-		dispatchNewLocals(EntityEvent.ATTACH, EntityEvent.STOCK, 
+		dispatchNewLocals(EntityEvent.CREATE, EntityEvent.ATTACH, EntityEvent.STOCK, 
 				changePlan, creations, leader, p);		
-		
-		// el detach esta muy mal: donde se haga un REMOVE (no detach) tengo que enviar luego un DROP
-		dispatchNewLocals(EntityEvent.REMOVE, EntityEvent.DROP, 
+		dispatchNewLocals(EntityEvent.REMOVE, EntityEvent.DETACH, EntityEvent.DROP,
 				changePlan, deletions, null, p);
-		
 		// those of older plans (new followers may have turned online)
 		dispatchCurrentLocals(scheme, changePlan, p, leader);
 	}
 
-	/** ChangePlan::ship leader's follower allocated duties (curr plan) to all followers */
 	private void dispatchNewLocals(
-			final EntityEvent cause,
-			final EntityEvent effect,
+			final EntityEvent evidence,
+			final EntityEvent action,
+			final EntityEvent reaction,
 			final ChangePlan changePlan, 
 			final Set<ShardEntity> involved,
-			final Shard target,
+			final Shard leader,
 			final Pallet p) {
 		
 		final CommitedState cs = scheme.getCommitedState();
-		// not all de/allocations, only those shipped to leader's local follower (same shard)
-		changePlan.onShippingsFor(cause, target, duty-> {
+		// those being shipped for the action event
+		changePlan.onShippingsFor(action, leader, duty-> {
 			// same pallet, and present as new CRUD (involved)
 			if (duty.getDuty().getPalletId().equals(p.getId()) && involved.contains(duty)) {
+				long pid = changePlan.getId();
+				// search back the evidence event as authentic purpose to reaction
+				while (pid > 1) {
+					if (duty.getCommitTree().findOne(pid, leader.getShardID(), evidence)!=null) {
 						cs.findShards(
-						attachPredicate(target, duty),
-						replicate(changePlan, duty, effect)
+								predicate(action, leader, duty),
+								replicate(changePlan, duty, reaction)
 						);
+						break;
 					}
-		});
-	
 				}
-	
-	private void dispatchKillingLocals(
-			final EntityEvent cause,
-			final EntityEvent effect,
-			final ChangePlan changePlan, 
-			final Set<ShardEntity> involved,
-			final Pallet p) {
-		
-		final CommitedState cs = scheme.getCommitedState();
-		// not all de/allocations, only those shipped to leader's local follower (same shard)
-		changePlan.onShippingsFor(cause, null, duty-> {
-			// same pallet, and present as new CRUD (involved)
-			if (duty.getDuty().getPalletId().equals(p.getId()) && involved.contains(duty)) { 				
-				cs.findShards(
-						removePredicate(target, duty),
-						replicate(changePlan, duty, effect)
-				);
 			}
 		});
-	
 	}
 	
 	/**
